#alloc frameBuffer[0x6600]: u8
export const FRAME_BUFFER:usize = (&frameBuffer);

// allocate memory for 8 RAM, 4 ROM pages
// 0..7 - 128K RAM pages; 8 = 128 rom 0, 9 = 128 rom 1, 10 = 48 rom, 11 = scratch area for ROM writes
#alloc machineMemory[0x30000]: u8
export const MACHINE_MEMORY:usize = (&machineMemory);

#alloc memoryPageReadMap[4]: u8
#alloc memoryPageWriteMap[4]: u8
export const MEMORY_PAGE_READ_MAP:usize = (&memoryPageReadMap);
export const MEMORY_PAGE_WRITE_MAP:usize = (&memoryPageWriteMap);

#alloc pageIsContended[12]: u8
pageIsContended = [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0];

#regpair AF A F
export const REGISTERS:usize = (&AF);
#regpair BC B C
#regpair DE D E
#regpair HL H L
#regpair AF_
#regpair BC_
#regpair DE_
#regpair HL_
#regpair IX IXH IXL
#regpair IY IYH IYL
#regpair SP
#regpair IR I R

#const FLAG_C 0x01
#const FLAG_N 0x02
#const FLAG_P 0x04
#const FLAG_V 0x04
#const FLAG_3 0x08
#const FLAG_H 0x10
#const FLAG_5 0x20
#const FLAG_Z 0x40
#const FLAG_S 0x80

#alloc halfcarryAddTable[8]: u8
halfcarryAddTable = [0, FLAG_H, FLAG_H, FLAG_H, 0, 0, 0, FLAG_H];

#alloc halfcarrySubTable[8]: u8
halfcarrySubTable = [0, 0, FLAG_H, 0, FLAG_H, 0, FLAG_H, FLAG_H];

#alloc overflowAddTable[8]: u8
overflowAddTable = [0, 0, 0, FLAG_V, FLAG_V, 0, 0, 0];
#alloc overflowSubTable[8]: u8
overflowSubTable = [0, FLAG_V, 0, 0, 0, 0, FLAG_V, 0];

#alloc sz53Table[0x100]: u8
#alloc parityTable[0x100]: u8
#alloc sz53pTable[0x100]: u8

#alloc contentionTable[72000]: u8

#alloc screenEvents[36000]: u32

#alloc keyStates[8]: u8

#alloc logEntries[2048]: u16
export const LOG_ENTRIES:usize = (&logEntries);

let i:u8 = 0;
while (true) {
    sz53Table[i] = u8(i) & ( FLAG_3 | FLAG_5 | FLAG_S );
    let j = i;
    let parity:u8 = 0;
    for (let k:i8 = 0; k < 8; k++) {
        parity ^= j & 1;
        j >>= 1;
    }

    parityTable[i] = (parity ? 0 : FLAG_P);
    sz53pTable[i] = sz53Table[i] | parityTable[i];

    sz53Table[0] |= FLAG_Z;
    sz53pTable[0] |= FLAG_Z;
    i++;
    if (i == 0) break;
}


function buildScreenEventsTable(mainScreenStartTstate:u32, tstatesPerRow:u32):void {
    /* build screen events table: a list of which screen bytes should be fetched on which
    t-states. A sequence of: two u32s per event:
    - tstate number or 0xffffffff for end marker
    - screen address offset | (attr address offset << 16),
    or 0xffffffff if this is a 'fetch border' event
    */
    let screenEventPointer:u32 = 0;

    /* top border */
    for (let y:u32 = 0; y < 24; y++) {
        const rowTime:u32 = mainScreenStartTstate - (24 - y) * tstatesPerRow - 16;
        for (let x:u32 = 0; x < 160; x++) {
            screenEvents[screenEventPointer++] = rowTime + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    for (let y:u32 = 0; y < 192; y++) {
        const rowTime:u32 = mainScreenStartTstate + tstatesPerRow * y;
        const rowScreenOffset:u32 = ((y & 0xc0) << 5) | ((y & 0x07) << 8) | ((y & 0x38) << 2);
        const rowAttrOffset:u32 = 0x1800 | ((y & 0xf8) << 2);

        /* left border */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime - 16 + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }

        /* main screen */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime + 8 * x;
            const screenOffset:u32 = rowScreenOffset | (x << 1);
            const attrOffset:u32 = rowAttrOffset | (x << 1);
            screenEvents[screenEventPointer++] = screenOffset | (attrOffset << 16);
        }

        /* right border */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime + 128 + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    /* bottom border */
    for (let y:u32 = 0; y < 24; y++) {
        const rowTime:u32 = mainScreenStartTstate + (192 + y) * tstatesPerRow - 16;
        for (let x:u32 = 0; x < 160; x++) {
            screenEvents[screenEventPointer++] = rowTime + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    // add end marker
    screenEvents[screenEventPointer] = 0xffffffff;
}

function buildContentionTable(mainScreenStartTstate:u32, tstatesPerRow:u32, frameCycleCount:u32):void {
    let pos:u32 = 0;
    while (pos < mainScreenStartTstate) {
        contentionTable[pos++] = 0;
    }
    for (let y:u32 = 0; y < 192; y++) {
        for (let x:u32 = 0; x < tstatesPerRow; x++) {
            if (x < 128) {
                const seq:u32 = x & 0x07;
                contentionTable[pos++] = u8((seq == 7) ? 0 : (6 - seq));
            } else {
                contentionTable[pos++] = 0;
            }
        }
    }
    while (pos < frameCycleCount) {
        contentionTable[pos++] = 0;
    }
}

let frameCycleCount:u32 = 69888;
let screenPageIndex:u32 = 5;
let pagingLocked:bool = 0;
let t:u32 = 0;
let pc:u16 = 0;
let iff1:bool = 0;
let iff2:bool = 0;
let im:u8 = 0;
let interruptible:bool = false;
let halted:bool = false;
let opcodePrefix:u8 = 0;
let framebufferIndex = 0;
let borderColour:u8 = 0;

// whether a trap on the next instruction will be honoured
let willTrap:bool = true;

let loggingEnabled:bool = false;
let logPtr = 0;

let machineType:u32 = 48;
export function setMachineType(type:u32):void {
    machineType = type;
    if (type == 48 || type == 1212) {
        frameCycleCount = 69888;
        buildScreenEventsTable(14335, 224);
        buildContentionTable(14335, 224, frameCycleCount);
    } else {  // 128
        frameCycleCount = 70908;
        buildScreenEventsTable(14361, 228);
        buildContentionTable(14361, 228, frameCycleCount);
    }
    reset();
}
export function reset():void {
    if (machineType == 48) {
        memoryPageReadMap = [10, 5, 2, 0];
        memoryPageWriteMap = [11, 5, 2, 0];
        pagingLocked = 1;
    } else if (machineType == 1212) {
        // 1212 = test machine type with writeable ROM
        memoryPageReadMap = [10, 5, 2, 0];
        memoryPageWriteMap = [10, 5, 2, 0];
        pagingLocked = 1;
    } else {  // 128
        memoryPageReadMap = [8, 5, 2, 0];
        memoryPageWriteMap = [11, 5, 2, 0];
        pagingLocked = 0;
    }
    screenPageIndex = 5;
    t = 0;
    pc = 0;
    iff1 = iff2 = 0;
    im = 0;
    interruptible = false;
    halted = false;
    opcodePrefix = 0;
    framebufferIndex = 0;
}
setMachineType(48);

for (let i=0; i < 8; i++) {
    keyStates[i] = 0xff;
}

export function setRegisters(af:u16, bc:u16, de:u16, hl:u16, af_:u16, bc_:u16, de_:u16, hl_:u16, ix:u16, iy:u16, sp:u16, ir:u16):void {
    AF = af;
    BC = bc;
    DE = de;
    HL = hl;
    AF_ = af_;
    BC_ = bc_;
    DE_ = de_;
    HL_ = hl_;
    IX = ix;
    IY = iy;
    SP = sp;
    IR = ir;
}

export function setPC(val:u16):void {
    pc = val;
}
export function getPC():u16 {
    return pc;
}
export function setIFF1(val:bool):void {
    iff1 = val;
}
export function getIFF1():bool {
    return iff1;
}
export function setIFF2(val:bool):void {
    iff2 = val;
}
export function getIFF2():bool {
    return iff2;
}
export function setIM(val:u8):void {
    im = val;
}
export function getIM():u8 {
    return im;
}
export function setTStates(val:u32):void {
    t = val;
}
export function getTStates():u32 {
    return t;
}
export function setHalted(val:bool):void {
    halted = val;
}
export function getHalted():bool {
    return halted;
}

function log(time:u32, type:u16, addr:u16, val:u8):void {
    logEntries[logPtr++] = u16(time);
    logEntries[logPtr++] = type;
    logEntries[logPtr++] = addr;
    logEntries[logPtr++] = u16(val);
    logPtr = logPtr % 2048;
}

export function startLog():void {
    loggingEnabled = true;
    logPtr = 0;
}
export function stopLog():void {
    log(0xffff, 0xffff, 0, 0);
    loggingEnabled = false;
}


function readMem(addr:u16):u8 {
    const page:u8 = memoryPageReadMap[addr >> 14];
    const pageOffset:u32 = u32(page) << 14;
    if (loggingEnabled) log(t, 3, addr, 0);
    if (pageIsContended[page]) t += contentionTable[t % frameCycleCount];
    t += 3;
    if (loggingEnabled) {
        const val:u8 = machineMemory[pageOffset | (addr & 0x3fff)];
        log(t, 1, addr, val);
        return val;
    } else {
        return machineMemory[pageOffset | (addr & 0x3fff)];
    }
}

function readMemInternal(addr:u16):u8 {
    const page:u8 = memoryPageReadMap[addr >> 14];
    const pageOffset:u32 = u32(page) << 14;
    if (loggingEnabled) {
        const val:u8 = machineMemory[pageOffset | (addr & 0x3fff)];
        log(t, 1, addr, val);
        return val;
    } else {
        return machineMemory[pageOffset | (addr & 0x3fff)];
    }
}

function writeMem(addr:u16, val:u8):void {
    const page:u8 = memoryPageWriteMap[addr >> 14];
    const pageOffset:u32 = u32(page) << 14;
    if (loggingEnabled) log(t, 3, addr, 0);
    if (pageIsContended[page]) t += contentionTable[t % frameCycleCount];
    if (page == screenPageIndex && pageOffset < 0x1b00) {
        updateFramebuffer();
    }
    machineMemory[pageOffset | (addr & 0x3fff)] = val;
    t += 3;
    if (loggingEnabled) {
        log(t, 2, addr, val);
    }
}

function contendRead(addr:u16):void {
    const page:u8 = memoryPageReadMap[addr >> 14];
    if (loggingEnabled) log(t, 3, addr, 0);
    if (pageIsContended[page]) t += contentionTable[t % frameCycleCount];
}
function contendDirtyRead(addr:u16):void {
    const page:u8 = memoryPageReadMap[addr >> 14];
    if (loggingEnabled) log(t, 3, addr, 0);
    if (pageIsContended[page]) t += contentionTable[t % frameCycleCount];
}
function contendDirtyWrite(addr:u16):void {
    const page:u8 = memoryPageWriteMap[addr >> 14];
    if (loggingEnabled) log(t, 3, addr, 0);
    if (pageIsContended[page]) t += contentionTable[t % frameCycleCount];
}

export function peek(addr:u16):u8 {
    const pageOffset:u32 = u32(memoryPageReadMap[addr >> 14]) << 14;
    return machineMemory[pageOffset | (addr & 0x3fff)];
}
export function poke(addr:u16, val:u8):void {
    const pageOffset:u32 = u32(memoryPageWriteMap[addr >> 14]) << 14;
    machineMemory[pageOffset | (addr & 0x3fff)] = val;
}

export function readPort(addr:u16):u8 {
    /* apply pre-read contention */
    const page:u8 = memoryPageReadMap[addr >> 14];
    const addressIsContended:u8 = pageIsContended[page];
    if (addressIsContended) {
        if (loggingEnabled) log(t, 6, addr, 0);
        t += contentionTable[t % frameCycleCount];
    }
    t++;

    let result:u8 = 0xff;
    if (machineType == 1212) {
        /*
        on port reads, the test machine just responds with the high byte of the port address.
        That's a thing now, I decided. (Well, Phil Kendall decided it to be exact.)
        */
        result = u8(addr >> 8);
    } else {

        if (!(addr & 0x0001)) {
            /* poll keyboard */
            result = pollKeyboard(u8(addr >> 8));
        } else if (!(addr & 0x00e0)) {
            /* kempston joystick */
            result = 0;
        }
    }
    if (loggingEnabled) log(t, 4, addr, result);

    /* apply post-read contention */
    if (addr & 0x0001) {
        if (addressIsContended) {
            if (loggingEnabled) log(t, 6, addr, 0);
            t += contentionTable[t % frameCycleCount];
            t++;
            if (loggingEnabled) log(t, 6, addr, 0);
            t += contentionTable[t % frameCycleCount];
            t++;
            if (loggingEnabled) log(t, 6, addr, 0);
            t += contentionTable[t % frameCycleCount];
            t++;
        } else {
            t += 3;
        }
    } else {
        if (loggingEnabled) log(t, 6, addr, 0);
        t += contentionTable[t % frameCycleCount];
        t += 3;
    }

    return result;
}

export function writePort(addr:u16, val:u8):void {
    /* apply pre-write contention */
    const page:u8 = memoryPageWriteMap[addr >> 14];
    const addressIsContended:u8 = pageIsContended[page];
    if (addressIsContended) {
        if (loggingEnabled) log(t, 6, addr, 0);
        t += contentionTable[t % frameCycleCount];
    }
    t++;

    if (loggingEnabled) log(t, 5, addr, val);
    if (!(addr & 0x0001)) {
        /* border colour / speaker */
        updateFramebuffer();  // apply all screen upates up to this point
        borderColour = val & 0x07;
    } else if (!(addr & 0x8002)) {
        /* 128/+2 paging */
        if (!pagingLocked) {

            updateFramebuffer();  // so that screen switching happens at the right position

            memoryPageReadMap[3] = val & 0x07;
            memoryPageWriteMap[3] = val & 0x07;
            screenPageIndex = (val & 0x08) ? 7 : 5;
            memoryPageReadMap[0] = (val & 0x10) ? 9 : 8;
            pagingLocked = bool(val & 0x20);
        }
    }

    /* apply post-write contention */
    if (addr & 0x0001) {
        if (addressIsContended) {
            if (loggingEnabled) log(t, 6, addr, 0);
            t += contentionTable[t % frameCycleCount];
            t++;
            if (loggingEnabled) log(t, 6, addr, 0);
            t += contentionTable[t % frameCycleCount];
            t++;
            if (loggingEnabled) log(t, 6, addr, 0);
            t += contentionTable[t % frameCycleCount];
            t++;
        } else {
            t += 3;
        }
    } else {
        if (loggingEnabled) log(t, 6, addr, 0);
        t += contentionTable[t % frameCycleCount];
        t += 3;
    }

}

let screenEventPointer:u32 = 0;

function updateFramebuffer():void {
    /* process all of the screen bytes that are due up to the current tstate */
    const screenBaseAddr:u32 = screenPageIndex << 14;

    // end marker is 0xffffffff, which will always be greater than t
    while (screenEvents[screenEventPointer] <= t) {
        const addressWord:u32 = screenEvents[screenEventPointer + 1];
        if (addressWord == 0xffffffff) {
            frameBuffer[framebufferIndex++] = borderColour;
        } else {
            const screenAddr:u32 = screenBaseAddr | (addressWord & 0xffff);
            const attributeAddr:u32 = screenBaseAddr | (addressWord >> 16);
            frameBuffer[framebufferIndex++] = machineMemory[screenAddr];
            frameBuffer[framebufferIndex++] = machineMemory[attributeAddr];
            frameBuffer[framebufferIndex++] = machineMemory[screenAddr + 1];
            frameBuffer[framebufferIndex++] = machineMemory[attributeAddr + 1];
        }
        screenEventPointer += 2;
    }
}

export function keyDown(row:u8, mask:u8):void {
    keyStates[row] = keyStates[row] & ~mask;
}
export function keyUp(row:u8, mask:u8):void {
    keyStates[row] = keyStates[row] | mask;
}

function pollKeyboard(addr:u8):u8 {
    let result:u8 = 0xff;
    for (let row:u8 = 0; row < 8; row++) {
        if (!(addr & (1<<row))) {
            /* scan this row */
            result &= keyStates[row];
        }
    }
    return result;
}

/* status codes returned from runFrame / resumeFrame:
0 = OK (end of frame)
1 = unrecognised opcode (should never happen...)
*/

export function runFrame():i16 {
    screenEventPointer = 0;
    framebufferIndex = 0;
    return resumeFrame();
}

export function resumeFrame():i16 {
    const status = runUntil(frameCycleCount);
    if (status) {
        // a non-zero status indicates we've broken out of the frame prematurely
        // and will need to resume it with resumeFrame.
        // When we do, a trap on the next instruction back will not be honoured
        // (so that it's possible for the trap to leave pc unchanged without putting us
        // in an infinite loop).
        willTrap = false;
        return status;
    }

    updateFramebuffer();
    t -= frameCycleCount;

    return 0;
}

export function runUntil(maxT:u32):i16 {
    while (t < maxT || opcodePrefix) {
        if (t < 36 && iff1 && interruptible) {
            /* process interrupt */

            if (halted) {
                // move PC on from the HALT opcode
                pc++;
                halted = 0;
            }

            iff1 = iff2 = 0;

            /* push current PC in readiness for call to interrupt handler */
            let sp = SP;
            sp--;
            writeMem(sp, u8(pc >> 8));
            sp--;
            writeMem(sp, u8(pc & 0xff));
            SP = sp;

            if (im == 1) {
                pc = 0x0038;
                t += 7;
            } else if (im == 2) {
                const intVector:u16 = (u16(I) << 8) | 0xff;
                const lo:u16 = u16(readMem(intVector));
                const hi:u16 = u16(readMem(intVector + 1));
                pc = (lo | (hi << 8));
                t += 7;
            } else { /* im == 0 */
                pc = 0x0038;
                t += 6;
            }
        }

        if (
            (pc == 0x056b || pc == 0x0111)
            && (memoryPageReadMap[0] == 9 || memoryPageReadMap[0] == 10)
            && willTrap
        ) {
            // tape loading trap
            return 2;
        }
        willTrap = true;

        interruptible = true; // unless overridden by opcode
        if (opcodePrefix == 0) {
            contendRead(pc);
            t += 4;
            let op:u8 = readMemInternal(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            switch (op) {
                #optable base

                default:
                    return 1;  /* unrecognised opcode */
            }
        } else if (opcodePrefix == 0xcb) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            contendRead(pc);
            t += 4;
            let op:u8 = readMemInternal(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            switch (op) {
                #optable cb

                default:
                    return 1;  /* unrecognised opcode */
            }
        } else if (opcodePrefix == 0xdd) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            contendRead(pc);
            t += 4;
            let op:u8 = readMemInternal(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            switch (op) {
                #optable dd

                default:
                    return 1;  /* unrecognised opcode */
            }
        } else if (opcodePrefix == 0xdc) {  // ddcb
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            const indexOffset:i8 = i8(readMem(pc++));
            let op:u8 = readMem(pc++);
            switch (op) {
                #optable ddcb

                default:
                    return 1;  /* unrecognised opcode */
            }
        } else if (opcodePrefix == 0xed) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            contendRead(pc);
            t += 4;
            let op:u8 = readMemInternal(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            switch (op) {
                #optable ed

                default:
                    return 1;  /* unrecognised opcode */
            }
        } else if (opcodePrefix == 0xfd) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            contendRead(pc);
            t += 4;
            let op:u8 = readMemInternal(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            switch (op) {
                #optable fd

                default:
                    return 1;  /* unrecognised opcode */
            }
        } else if (opcodePrefix == 0xfc) {  // fdcb
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            const indexOffset:i8 = i8(readMem(pc++));
            let op:u8 = readMem(pc++);
            switch (op) {
                #optable fdcb

                default:
                    return 1;  /* unrecognised opcode */
            }
        }
    }

    return 0;
}
