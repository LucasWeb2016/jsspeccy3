#alloc frameBuffer[0x6600]: u8
#const FRAME_BUFFER_SIZE 0x6600

// allocate memory for 8 RAM, 4 ROM pages
#alloc machineMemory[0x30000]: u8

#alloc memoryPageMap[4]: u8

#regpair AF A F
#regpair BC B C
#regpair DE D E
#regpair HL H L
#regpair AF_
#regpair BC_
#regpair DE_
#regpair HL_
#regpair IX IXH IXL
#regpair IY IYH IYL
#regpair SP
#regpair IR I R

#const FLAG_C 0x01
#const FLAG_N 0x02
#const FLAG_P 0x04
#const FLAG_V 0x04
#const FLAG_3 0x08
#const FLAG_H 0x10
#const FLAG_5 0x20
#const FLAG_Z 0x40
#const FLAG_S 0x80

#alloc halfcarryAddTable[8]: u8
halfcarryAddTable = [0, FLAG_H, FLAG_H, FLAG_H, 0, 0, 0, FLAG_H];

#alloc halfcarrySubTable[8]: u8
halfcarrySubTable = [0, 0, FLAG_H, 0, FLAG_H, 0, FLAG_H, FLAG_H];

#alloc overflowAddTable[8]: u8
overflowAddTable = [0, 0, 0, FLAG_V, FLAG_V, 0, 0, 0];
#alloc overflowSubTable[8]: u8
overflowSubTable = [0, FLAG_V, 0, 0, 0, 0, FLAG_V, 0];

#alloc sz53Table[0x100]: u8
#alloc parityTable[0x100]: u8
#alloc sz53pTable[0x100]: u8

#alloc screenEvents[36000]: u32

#alloc keyStates[8]: u8

let i:u8 = 0;
while (true) {
    sz53Table[i] = u8(i) & ( FLAG_3 | FLAG_5 | FLAG_S );
    let j = i;
    let parity:u8 = 0;
    for (let k:i8 = 0; k < 8; k++) {
        parity ^= j & 1;
        j >>= 1;
    }

    parityTable[i] = (parity ? 0 : FLAG_P);
    sz53pTable[i] = sz53Table[i] | parityTable[i];

    sz53Table[0] |= FLAG_Z;
    sz53pTable[0] |= FLAG_Z;
    i++;
    if (i == 0) break;
}


function buildScreenEventsTable(mainScreenStartTstate:u32, tstatesPerRow:u32):void {
    /* build screen events table: a list of which screen bytes should be fetched on which
    t-states. A sequence of: two u32s per event:
    - tstate number or 0xffffffff for end marker
    - screen address offset | (attr address offset << 16),
    or 0xffffffff if this is a 'fetch border' event
    */
    let screenEventPointer:u32 = 0;

    /* top border */
    for (let y:u32 = 0; y < 24; y++) {
        const rowTime:u32 = mainScreenStartTstate - (24 - y) * tstatesPerRow - 16;
        for (let x:u32 = 0; x < 160; x++) {
            screenEvents[screenEventPointer++] = rowTime + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    for (let y:u32 = 0; y < 192; y++) {
        const rowTime:u32 = mainScreenStartTstate + tstatesPerRow * y;
        const rowScreenOffset:u32 = ((y & 0xc0) << 5) | ((y & 0x07) << 8) | ((y & 0x38) << 2);
        const rowAttrOffset:u32 = 0x1800 | ((y & 0xf8) << 2);

        /* left border */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime - 16 + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }

        /* main screen */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime + 8 * x;
            const screenOffset:u32 = rowScreenOffset | (x << 1);
            const attrOffset:u32 = rowAttrOffset | (x << 1);
            screenEvents[screenEventPointer++] = screenOffset | (attrOffset << 16);
        }

        /* right border */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime + 128 + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    /* bottom border */
    for (let y:u32 = 0; y < 24; y++) {
        const rowTime:u32 = mainScreenStartTstate + (192 + y) * tstatesPerRow - 16;
        for (let x:u32 = 0; x < 160; x++) {
            screenEvents[screenEventPointer++] = rowTime + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    // add end marker
    screenEvents[screenEventPointer] = 0xffffffff;
}

let frameCycleCount:u32 = 69888;
let screenPageIndex:u32 = 5;
let pagingLocked:bool = 0;
let t:u32 = 0;
let pc:u16 = 0;
let iff1:bool = 0;
let iff2:bool = 0;
let im:u8 = 0;
let interruptible:bool = false;
let halted:bool = false;
let opcodePrefix:u8 = 0;
let framebufferIndex = 0;
let borderColour:u8 = 0;


let machineType:u32 = 48;
export function setMachineType(type:u32):void {
    machineType = type;
    if (type == 48) {
        frameCycleCount = 69888;
        buildScreenEventsTable(14335, 224);
    } else {  // 128
        frameCycleCount = 70908;
        buildScreenEventsTable(14361, 228);
    }
    reset();
}
export function reset():void {
    if (machineType == 48) {
        memoryPageMap = [10, 5, 2, 0];
        pagingLocked = 1;
    } else {  // 128
        memoryPageMap = [8, 5, 2, 0];
        pagingLocked = 0;
    }
    screenPageIndex = 5;
    t = 0;
    pc = 0;
    iff1 = iff2 = 0;
    im = 0;
    interruptible = false;
    halted = false;
    opcodePrefix = 0;
    framebufferIndex = 0;
}
setMachineType(48);

for (let i=0; i < 8; i++) {
    keyStates[i] = 0xff;
}

export function setRegisters(af:u16, bc:u16, de:u16, hl:u16, af_:u16, bc_:u16, de_:u16, hl_:u16, ix:u16, iy:u16, sp:u16, ir:u16):void {
    AF = af;
    BC = bc;
    DE = de;
    HL = hl;
    AF_ = af_;
    BC_ = bc_;
    DE_ = de_;
    HL_ = hl_;
    IX = ix;
    IY = iy;
    SP = sp;
    IR = ir;
}

export function setPC(val:u16):void {
    pc = val;
}
export function getPC():u16 {
    return pc;
}
export function setIFF1(val:bool):void {
    iff1 = val;
}
export function getIFF1():bool {
    return iff1;
}
export function setIFF2(val:bool):void {
    iff2 = val;
}
export function getIFF2():bool {
    return iff2;
}
export function setIM(val:u8):void {
    im = val;
}
export function getIM():u8 {
    return im;
}
export function setTStates(val:u32):void {
    t = val;
}

function readMem(addr:u16):u8 {
    t += 3;
    const pageOffset:u32 = u32(memoryPageMap[addr >> 14]) << 14;
    return machineMemory[pageOffset | (addr & 0x3fff)];
}

function writeMem(addr:u16, val:u8):void {
    t += 3;
    if (addr >= 0x4000 && addr < 0x5b00) {
        updateFramebuffer();
    }
    if (addr & 0xc000) {
        const pageOffset:u32 = u32(memoryPageMap[addr >> 14]) << 14;
        machineMemory[pageOffset | (addr & 0x3fff)] = val;
    }
}

export function peek(addr:u16):u8 {
    const pageOffset:u32 = u32(memoryPageMap[addr >> 14]) << 14;
    return machineMemory[pageOffset | (addr & 0x3fff)];
}
export function poke(addr:u16, val:u8):void {
    const pageOffset:u32 = u32(memoryPageMap[addr >> 14]) << 14;
    machineMemory[pageOffset | (addr & 0x3fff)] = val;
}

export function readPort(addr:u16):u8 {
    if (!(addr & 0x0001)) {
        /* poll keyboard */
        return pollKeyboard(u8(addr >> 8));
    } else if (!(addr & 0x00e0)) {
        /* kempston joystick */
        return 0;
    } else {
        return 0xff;
    }
}

export function writePort(addr:u16, val:u8):void {
    if (!(addr & 0x0001)) {
        /* border colour / speaker */
        borderColour = val & 0x07;
    } else if (!(addr & 0x8002)) {
        /* 128/+2 paging */
        if (pagingLocked) return;

        updateFramebuffer();  // so that screen switching happens at the right position

        memoryPageMap[3] = val & 0x07;
        screenPageIndex = (val & 0x08) ? 7 : 5;
        memoryPageMap[0] = (val & 0x10) ? 9 : 8;
        pagingLocked = bool(val & 0x20);
    }
}

let screenEventPointer:u32 = 0;

function updateFramebuffer():void {
    /* process all of the screen bytes that are due up to the current tstate */
    const screenBaseAddr:u32 = screenPageIndex << 14;

    // end marker is 0xffffffff, which will always be greater than t
    while (screenEvents[screenEventPointer] <= t) {
        const addressWord:u32 = screenEvents[screenEventPointer + 1];
        if (addressWord == 0xffffffff) {
            frameBuffer[framebufferIndex++] = borderColour;
        } else {
            const screenAddr:u32 = screenBaseAddr | (addressWord & 0xffff);
            const attributeAddr:u32 = screenBaseAddr | (addressWord >> 16);
            frameBuffer[framebufferIndex++] = machineMemory[screenAddr];
            frameBuffer[framebufferIndex++] = machineMemory[attributeAddr];
            frameBuffer[framebufferIndex++] = machineMemory[screenAddr + 1];
            frameBuffer[framebufferIndex++] = machineMemory[attributeAddr + 1];
        }
        screenEventPointer += 2;
    }
}

export function keyDown(row:u8, mask:u8):void {
    keyStates[row] = keyStates[row] & ~mask;
}
export function keyUp(row:u8, mask:u8):void {
    keyStates[row] = keyStates[row] | mask;
}

function pollKeyboard(addr:u8):u8 {
    let result:u8 = 0xff;
    for (let row:u8 = 0; row < 8; row++) {
        if (!(addr & (1<<row))) {
            /* scan this row */
            result &= keyStates[row];
        }
    }
    return result;
}

export function runFrame():i16 {
    screenEventPointer = 0;
    framebufferIndex = 0;
    const result = runUntil(frameCycleCount);
    if (result != -1) {
        t = frameCycleCount;
        updateFramebuffer();
        return result;
    }

    updateFramebuffer();
    t -= frameCycleCount;

    return -1;
}

export function runUntil(maxT:u32):i16 {
    while (t < maxT || !interruptible) {
        //if (pc == 0x10af && machineMemory[0x5c3b] != 0x00) {
        //    return machineMemory[0x5c3b];
        //}

        if (t < 36 && iff1 && interruptible) {
            /* process interrupt */

            if (halted) {
                // move PC on from the HALT opcode
                pc++;
                halted = 0;
            }

            iff1 = iff2 = 0;

            /* push current PC in readiness for call to interrupt handler */
            let sp = SP;
            sp--;
            writeMem(sp, u8(pc >> 8));
            sp--;
            writeMem(sp, u8(pc & 0xff));
            SP = sp;

            if (im == 1) {
                pc = 0x0038;
                t += 7;
            } else if (im == 2) {
                const intVector:u16 = (u16(I) << 8) | 0xff;
                const lo = readMem(intVector);
                const hi = readMem(intVector + 1);
                pc = (lo | (hi << 8));
                t += 7;
            } else { /* im == 0 */
                pc = 0x0038;
                t += 6;
            }
        }

        interruptible = true; // unless overridden by opcode
        if (opcodePrefix == 0) {
            let op:u8 = readMem(pc++);
            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #op 00 NOP
                #op 01 LD BC,nn
                #op 02 LD (BC),A
                #op 03 INC BC
                #op 04 INC B
                #op 05 DEC B
                #op 06 LD B,n
                #op 07 RLCA
                #op 08 EX AF,AF'
                #op 09 ADD HL,BC
                #op 0a LD A,(BC)
                #op 0b DEC BC
                #op 0c INC C
                #op 0d DEC C
                #op 0e LD C,n
                #op 0f RRCA

                #op 10 DJNZ n
                #op 11 LD DE,nn
                #op 12 LD (DE),A
                #op 13 INC DE
                #op 14 INC D
                #op 15 DEC D
                #op 16 LD D,n
                #op 17 RLA
                #op 18 JR n
                #op 19 ADD HL,DE
                #op 1a LD A,(DE)
                #op 1b DEC DE
                #op 1c INC E
                #op 1d DEC E
                #op 1e LD E,n
                #op 1f RRA

                #op 20 JR NZ,n
                #op 21 LD HL,nn
                #op 22 LD (nn),HL
                #op 23 INC HL
                #op 24 INC H
                #op 25 DEC H
                #op 26 LD H,n
                #op 27 DAA
                #op 28 JR Z,n
                #op 29 ADD HL,HL
                #op 2a LD HL,(nn)
                #op 2b DEC HL
                #op 2c INC L
                #op 2d DEC L
                #op 2e LD L,n
                #op 2f CPL

                #op 30 JR NC,n
                #op 31 LD SP,nn
                #op 32 LD (nn),A
                #op 33 INC SP
                #op 34 INC (HL)
                #op 35 DEC (HL)
                #op 36 LD (HL),n
                #op 37 SCF
                #op 38 JR C,n
                #op 39 ADD HL,SP
                #op 3a LD A,(nn)
                #op 3b DEC SP
                #op 3c INC A
                #op 3d DEC A
                #op 3e LD A,n
                #op 3f CCF

                #op 40 LD B,B
                #op 41 LD B,C
                #op 42 LD B,D
                #op 43 LD B,E
                #op 44 LD B,H
                #op 45 LD B,L
                #op 46 LD B,(HL)
                #op 47 LD B,A
                #op 48 LD C,B
                #op 49 LD C,C
                #op 4a LD C,D
                #op 4b LD C,E
                #op 4c LD C,H
                #op 4d LD C,L
                #op 4e LD C,(HL)
                #op 4f LD C,A

                #op 50 LD D,B
                #op 51 LD D,C
                #op 52 LD D,D
                #op 53 LD D,E
                #op 54 LD D,H
                #op 55 LD D,L
                #op 56 LD D,(HL)
                #op 57 LD D,A
                #op 58 LD E,B
                #op 59 LD E,C
                #op 5a LD E,D
                #op 5b LD E,E
                #op 5c LD E,H
                #op 5d LD E,L
                #op 5e LD E,(HL)
                #op 5f LD E,A

                #op 60 LD H,B
                #op 61 LD H,C
                #op 62 LD H,D
                #op 63 LD H,E
                #op 64 LD H,H
                #op 65 LD H,L
                #op 66 LD H,(HL)
                #op 67 LD H,A
                #op 68 LD L,B
                #op 69 LD L,C
                #op 6a LD L,D
                #op 6b LD L,E
                #op 6c LD L,H
                #op 6d LD L,L
                #op 6e LD L,(HL)
                #op 6f LD L,A

                #op 70 LD (HL),B
                #op 71 LD (HL),C
                #op 72 LD (HL),D
                #op 73 LD (HL),E
                #op 74 LD (HL),H
                #op 75 LD (HL),L
                #op 76 HALT
                #op 77 LD (HL),A
                #op 78 LD A,B
                #op 79 LD A,C
                #op 7a LD A,D
                #op 7b LD A,E
                #op 7c LD A,H
                #op 7d LD A,L
                #op 7e LD A,(HL)
                #op 7f LD A,A

                #op 80 ADD A,B
                #op 81 ADD A,C
                #op 82 ADD A,D
                #op 83 ADD A,E
                #op 84 ADD A,H
                #op 85 ADD A,L
                #op 86 ADD A,(HL)
                #op 87 ADD A,A
                #op 88 ADC A,B
                #op 89 ADC A,C
                #op 8a ADC A,D
                #op 8b ADC A,E
                #op 8c ADC A,H
                #op 8d ADC A,L
                #op 8e ADC A,(HL)
                #op 8f ADC A,A

                #op 90 SUB B
                #op 91 SUB C
                #op 92 SUB D
                #op 93 SUB E
                #op 94 SUB H
                #op 95 SUB L
                #op 96 SUB (HL)
                #op 97 SUB A
                #op 98 SBC A,B
                #op 99 SBC A,C
                #op 9a SBC A,D
                #op 9b SBC A,E
                #op 9c SBC A,H
                #op 9d SBC A,L
                #op 9e SBC A,(HL)
                #op 9f SBC A,A

                #op a0 AND B
                #op a1 AND C
                #op a2 AND D
                #op a3 AND E
                #op a4 AND H
                #op a5 AND L
                #op a6 AND (HL)
                #op a7 AND A
                #op a8 XOR B
                #op a9 XOR C
                #op aa XOR D
                #op ab XOR E
                #op ac XOR H
                #op ad XOR L
                #op ae XOR (HL)
                #op af XOR A

                #op b0 OR B
                #op b1 OR C
                #op b2 OR D
                #op b3 OR E
                #op b4 OR H
                #op b5 OR L
                #op b6 OR (HL)
                #op b7 OR A
                #op b8 CP B
                #op b9 CP C
                #op ba CP D
                #op bb CP E
                #op bc CP H
                #op bd CP L
                #op be CP (HL)
                #op bf CP A

                #op c0 RET NZ
                #op c1 POP BC
                #op c2 JP NZ,nn
                #op c3 JP nn
                #op c4 CALL NZ,nn
                #op c5 PUSH BC
                #op c6 ADD A,n
                #op c7 RST 0x00
                #op c8 RET Z
                #op c9 RET
                #op ca JP Z,nn
                #op cb prefix cb
                #op cc CALL Z,nn
                #op cd CALL nn
                #op ce ADC A,n
                #op cf RST 0x08

                #op d0 RET NC
                #op d1 POP DE
                #op d2 JP NC,nn
                #op d3 OUT (n),A
                #op d4 CALL NC,nn
                #op d5 PUSH DE
                #op d6 SUB n
                #op d7 RST 0x10
                #op d8 RET C
                #op d9 EXX
                #op da JP C,nn
                #op db IN A,(n)
                #op dc CALL C,nn
                #op dd prefix dd
                #op de SBC A,n
                #op df RST 0x18

                #op e0 RET PO
                #op e1 POP HL
                #op e2 JP PO,nn
                #op e3 EX (SP),HL
                #op e4 CALL PO,nn
                #op e5 PUSH HL
                #op e6 AND n
                #op e7 RST 0x20
                #op e8 RET PE
                #op e9 JP (HL)
                #op ea JP PE,nn
                #op eb EX DE,HL
                #op ec CALL PE,nn
                #op ed prefix ed
                #op ee XOR n
                #op ef RST 0x28

                #op f0 RET P
                #op f1 POP AF
                #op f2 JP P,nn
                #op f3 DI
                #op f4 CALL P,nn
                #op f5 PUSH AF
                #op f6 OR n
                #op f7 RST 0x30
                #op f8 RET M
                #op f9 LD SP,HL
                #op fa JP M,nn
                #op fb EI
                #op fc CALL M,nn
                #op fd prefix fd
                #op fe CP n
                #op ff RST 0x38

                default:
                    return op;
            }
        } else if (opcodePrefix == 0xcb) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);
            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #op 00 RLC B
                #op 01 RLC C
                #op 02 RLC D
                #op 03 RLC E
                #op 04 RLC H
                #op 05 RLC L
                #op 06 RLC (HL)
                #op 07 RLC A

                #op 10 RL B
                #op 11 RL C
                #op 12 RL D
                #op 13 RL E
                #op 14 RL H
                #op 15 RL L
                #op 16 RL (HL)
                #op 17 RL A
                #op 18 RR B
                #op 19 RR C
                #op 1a RR D
                #op 1b RR E
                #op 1c RR H
                #op 1d RR L
                #op 1e RR (HL)
                #op 1f RR A

                #op 20 SLA B
                #op 21 SLA C
                #op 22 SLA D
                #op 23 SLA E
                #op 24 SLA H
                #op 25 SLA L
                #op 26 SLA (HL)
                #op 27 SLA A
                #op 28 SRA B
                #op 29 SRA C
                #op 2a SRA D
                #op 2b SRA E
                #op 2c SRA H
                #op 2d SRA L
                #op 2e SRA (HL)
                #op 2f SRA A

                #op 38 SRL B
                #op 39 SRL C
                #op 3a SRL D
                #op 3b SRL E
                #op 3c SRL H
                #op 3d SRL L
                #op 3e SRL (HL)
                #op 3f SRL A

                #op 40 BIT 0,B
                #op 41 BIT 0,C
                #op 42 BIT 0,D
                #op 43 BIT 0,E
                #op 44 BIT 0,H
                #op 45 BIT 0,L
                #op 46 BIT 0,(HL)
                #op 47 BIT 0,A
                #op 48 BIT 1,B
                #op 49 BIT 1,C
                #op 4a BIT 1,D
                #op 4b BIT 1,E
                #op 4c BIT 1,H
                #op 4d BIT 1,L
                #op 4e BIT 1,(HL)
                #op 4f BIT 1,A

                #op 50 BIT 2,B
                #op 51 BIT 2,C
                #op 52 BIT 2,D
                #op 53 BIT 2,E
                #op 54 BIT 2,H
                #op 55 BIT 2,L
                #op 56 BIT 2,(HL)
                #op 57 BIT 2,A
                #op 58 BIT 3,B
                #op 59 BIT 3,C
                #op 5a BIT 3,D
                #op 5b BIT 3,E
                #op 5c BIT 3,H
                #op 5d BIT 3,L
                #op 5e BIT 3,(HL)
                #op 5f BIT 3,A

                #op 60 BIT 4,B
                #op 61 BIT 4,C
                #op 62 BIT 4,D
                #op 63 BIT 4,E
                #op 64 BIT 4,H
                #op 65 BIT 4,L
                #op 66 BIT 4,(HL)
                #op 67 BIT 4,A
                #op 68 BIT 5,B
                #op 69 BIT 5,C
                #op 6a BIT 5,D
                #op 6b BIT 5,E
                #op 6c BIT 5,H
                #op 6d BIT 5,L
                #op 6e BIT 5,(HL)
                #op 6f BIT 5,A

                #op 70 BIT 6,B
                #op 71 BIT 6,C
                #op 72 BIT 6,D
                #op 73 BIT 6,E
                #op 74 BIT 6,H
                #op 75 BIT 6,L
                #op 76 BIT 6,(HL)
                #op 77 BIT 6,A
                #op 78 BIT 7,B
                #op 79 BIT 7,C
                #op 7a BIT 7,D
                #op 7b BIT 7,E
                #op 7c BIT 7,H
                #op 7d BIT 7,L
                #op 7e BIT 7,(HL)
                #op 7f BIT 7,A

                #op 80 RES 0,B
                #op 81 RES 0,C
                #op 82 RES 0,D
                #op 83 RES 0,E
                #op 84 RES 0,H
                #op 85 RES 0,L
                #op 86 RES 0,(HL)
                #op 87 RES 0,A
                #op 88 RES 1,B
                #op 89 RES 1,C
                #op 8a RES 1,D
                #op 8b RES 1,E
                #op 8c RES 1,H
                #op 8d RES 1,L
                #op 8e RES 1,(HL)
                #op 8f RES 1,A

                #op 90 RES 2,B
                #op 91 RES 2,C
                #op 92 RES 2,D
                #op 93 RES 2,E
                #op 94 RES 2,H
                #op 95 RES 2,L
                #op 96 RES 2,(HL)
                #op 97 RES 2,A
                #op 98 RES 3,B
                #op 99 RES 3,C
                #op 9a RES 3,D
                #op 9b RES 3,E
                #op 9c RES 3,H
                #op 9d RES 3,L
                #op 9e RES 3,(HL)
                #op 9f RES 3,A

                #op a0 RES 4,B
                #op a1 RES 4,C
                #op a2 RES 4,D
                #op a3 RES 4,E
                #op a4 RES 4,H
                #op a5 RES 4,L
                #op a6 RES 4,(HL)
                #op a7 RES 4,A
                #op a8 RES 5,B
                #op a9 RES 5,C
                #op aa RES 5,D
                #op ab RES 5,E
                #op ac RES 5,H
                #op ad RES 5,L
                #op ae RES 5,(HL)
                #op af RES 5,A

                #op b0 RES 6,B
                #op b1 RES 6,C
                #op b2 RES 6,D
                #op b3 RES 6,E
                #op b4 RES 6,H
                #op b5 RES 6,L
                #op b6 RES 6,(HL)
                #op b7 RES 6,A
                #op b8 RES 7,B
                #op b9 RES 7,C
                #op ba RES 7,D
                #op bb RES 7,E
                #op bc RES 7,H
                #op bd RES 7,L
                #op be RES 7,(HL)
                #op bf RES 7,A

                #op c0 SET 0,B
                #op c1 SET 0,C
                #op c2 SET 0,D
                #op c3 SET 0,E
                #op c4 SET 0,H
                #op c5 SET 0,L
                #op c6 SET 0,(HL)
                #op c7 SET 0,A
                #op c8 SET 1,B
                #op c9 SET 1,C
                #op ca SET 1,D
                #op cb SET 1,E
                #op cc SET 1,H
                #op cd SET 1,L
                #op ce SET 1,(HL)
                #op cf SET 1,A

                #op d0 SET 2,B
                #op d1 SET 2,C
                #op d2 SET 2,D
                #op d3 SET 2,E
                #op d4 SET 2,H
                #op d5 SET 2,L
                #op d6 SET 2,(HL)
                #op d7 SET 2,A
                #op d8 SET 3,B
                #op d9 SET 3,C
                #op da SET 3,D
                #op db SET 3,E
                #op dc SET 3,H
                #op dd SET 3,L
                #op de SET 3,(HL)
                #op df SET 3,A

                #op e0 SET 4,B
                #op e1 SET 4,C
                #op e2 SET 4,D
                #op e3 SET 4,E
                #op e4 SET 4,H
                #op e5 SET 4,L
                #op e6 SET 4,(HL)
                #op e7 SET 4,A
                #op e8 SET 5,B
                #op e9 SET 5,C
                #op ea SET 5,D
                #op eb SET 5,E
                #op ec SET 5,H
                #op ed SET 5,L
                #op ee SET 5,(HL)
                #op ef SET 5,A

                #op f0 SET 6,B
                #op f1 SET 6,C
                #op f2 SET 6,D
                #op f3 SET 6,E
                #op f4 SET 6,H
                #op f5 SET 6,L
                #op f6 SET 6,(HL)
                #op f7 SET 6,A
                #op f8 SET 7,B
                #op f9 SET 7,C
                #op fa SET 7,D
                #op fb SET 7,E
                #op fc SET 7,H
                #op fd SET 7,L
                #op fe SET 7,(HL)
                #op ff SET 7,A

                default:
                    return i16(0xc00) | i16(op);
            }
        } else if (opcodePrefix == 0xdd) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);
            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #op 09 ADD IX,BC
                #op 19 ADD IX,DE
                #op 21 LD IX,nn
                #op 29 ADD IX,IX
                #op 22 LD (nn),IX
                #op 23 INC IX
                #op 2a LD IX,(nn)
                #op 2b DEC IX
                #op 34 INC (IX+n)
                #op 35 DEC (IX+n)
                #op 36 LD (IX+n),n
                #op 39 ADD IX,SP
                #op 46 LD B,(IX+n)
                #op 4e LD C,(IX+n)
                #op 56 LD D,(IX+n)
                #op 5e LD E,(IX+n)
                #op 66 LD H,(IX+n)
                #op 6e LD L,(IX+n)
                #op 70 LD (IX+n),B
                #op 71 LD (IX+n),C
                #op 72 LD (IX+n),D
                #op 73 LD (IX+n),E
                #op 74 LD (IX+n),H
                #op 75 LD (IX+n),L
                #op 77 LD (IX+n),A
                #op 7e LD A,(IX+n)
                #op 86 ADD A,(IX+n)
                #op 8e ADC A,(IX+n)
                #op 96 SUB (IX+n)
                #op 9e SBC A,(IX+n)
                #op a6 AND (IX+n)
                #op ae XOR (IX+n)
                #op b6 OR (IX+n)
                #op be CP (IX+n)
                #op cb prefix ddcb
                #op e1 POP IX
                #op e3 EX (SP),IX
                #op e5 PUSH IX
                #op e9 JP (IX)
                #op f9 LD SP,IX

                default:
                    return i16(0xd00) | i16(op);
            }
        } else if (opcodePrefix == 0xdc) {  // ddcb
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            const indexOffset:i8 = i8(readMem(pc++));
            let op:u8 = readMem(pc++);
            switch (op) {
                #op 06 RLC (IX+n)

                #op 16 RL (IX+n)
                #op 1e RR (IX+n)

                #op 26 SLA (IX+n)
                #op 2e SRA (IX+n)

                #op 3e SRL (IX+n)

                #op 46 BIT 0,(IX+n)
                #op 4e BIT 1,(IX+n)
                #op 56 BIT 2,(IX+n)
                #op 5e BIT 3,(IX+n)
                #op 66 BIT 4,(IX+n)
                #op 6e BIT 5,(IX+n)
                #op 76 BIT 6,(IX+n)
                #op 7e BIT 7,(IX+n)

                #op 86 RES 0,(IX+n)
                #op 8e RES 1,(IX+n)
                #op 96 RES 2,(IX+n)
                #op 9e RES 3,(IX+n)
                #op a6 RES 4,(IX+n)
                #op ae RES 5,(IX+n)
                #op b6 RES 6,(IX+n)
                #op be RES 7,(IX+n)

                #op c6 SET 0,(IX+n)
                #op ce SET 1,(IX+n)
                #op d6 SET 2,(IX+n)
                #op de SET 3,(IX+n)
                #op e6 SET 4,(IX+n)
                #op ee SET 5,(IX+n)
                #op f6 SET 6,(IX+n)
                #op fe SET 7,(IX+n)

                default:
                    return i16(0x2c00) | i16(op);
            }
        } else if (opcodePrefix == 0xed) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);
            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #op 40 IN B,(C)
                #op 41 OUT (C),B
                #op 42 SBC HL,BC
                #op 43 LD (nn),BC
                #op 44 NEG
                #op 46 IM 0
                #op 47 LD I,A
                #op 48 IN C,(C)
                #op 49 OUT (C),C
                #op 4a ADC HL,BC
                #op 4b LD BC,(nn)

                #op 50 IN D,(C)
                #op 51 OUT (C),D
                #op 52 SBC HL,DE
                #op 53 LD (nn),DE
                #op 56 IM 1
                #op 58 IN E,(C)
                #op 59 OUT (C),E
                #op 5a ADC HL,DE
                #op 5b LD DE,(nn)
                #op 5e IM 2

                #op 60 IN H,(C)
                #op 61 OUT (C),H
                #op 62 SBC HL,HL
                #op 68 IN L,(C)
                #op 69 OUT (C),L
                #op 6a ADC HL,HL
                #op 6b LD HL,(nn)

                #op 72 SBC HL,SP
                #op 73 LD (nn),SP
                #op 78 IN A,(C)
                #op 79 OUT (C),A
                #op 7a ADC HL,SP

                #op a0 LDI
                #op a8 LDD
                #op b0 LDIR
                #op b8 LDDR

                default:
                    return i16(0xe00) | i16(op);
            }
        } else if (opcodePrefix == 0xfd) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);
            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #op 09 ADD IY,BC
                #op 19 ADD IY,DE
                #op 21 LD IY,nn
                #op 22 LD (nn),IY
                #op 23 INC IY
                #op 29 ADD IY,IY
                #op 2a LD IY,(nn)
                #op 2b DEC IY
                #op 34 INC (IY+n)
                #op 35 DEC (IY+n)
                #op 36 LD (IY+n),n
                #op 39 ADD IY,SP
                #op 46 LD B,(IY+n)
                #op 4e LD C,(IY+n)
                #op 56 LD D,(IY+n)
                #op 5e LD E,(IY+n)
                #op 66 LD H,(IY+n)
                #op 6e LD L,(IY+n)
                #op 70 LD (IY+n),B
                #op 71 LD (IY+n),C
                #op 72 LD (IY+n),D
                #op 73 LD (IY+n),E
                #op 74 LD (IY+n),H
                #op 75 LD (IY+n),L
                #op 77 LD (IY+n),A
                #op 7e LD A,(IY+n)
                #op 86 ADD A,(IY+n)
                #op 8e ADC A,(IY+n)
                #op 96 SUB (IY+n)
                #op 9e SBC A,(IY+n)
                #op a6 AND (IY+n)
                #op ae XOR (IY+n)
                #op b6 OR (IY+n)
                #op be CP (IY+n)
                #op cb prefix fdcb
                #op e1 POP IY
                #op e3 EX (SP),IY
                #op e5 PUSH IY
                #op e9 JP (IY)
                #op f9 LD SP,IY

                default:
                    return i16(0xf00) | i16(op);
            }
        } else if (opcodePrefix == 0xfc) {  // fdcb
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            const indexOffset:i8 = i8(readMem(pc++));
            let op:u8 = readMem(pc++);
            switch (op) {
                #op 06 RLC (IY+n)

                #op 16 RL (IY+n)
                #op 1e RR (IY+n)

                #op 26 SLA (IY+n)
                #op 2e SRA (IY+n)

                #op 3e SRL (IY+n)

                #op 46 BIT 0,(IY+n)
                #op 4e BIT 1,(IY+n)
                #op 56 BIT 2,(IY+n)
                #op 5e BIT 3,(IY+n)
                #op 66 BIT 4,(IY+n)
                #op 6e BIT 5,(IY+n)
                #op 76 BIT 6,(IY+n)
                #op 7e BIT 7,(IY+n)

                #op 86 RES 0,(IY+n)
                #op 8e RES 1,(IY+n)
                #op 96 RES 2,(IY+n)
                #op 9e RES 3,(IY+n)
                #op a6 RES 4,(IY+n)
                #op ae RES 5,(IY+n)
                #op b6 RES 6,(IY+n)
                #op be RES 7,(IY+n)

                #op c6 SET 0,(IY+n)
                #op ce SET 1,(IY+n)
                #op d6 SET 2,(IY+n)
                #op de SET 3,(IY+n)
                #op e6 SET 4,(IY+n)
                #op ee SET 5,(IY+n)
                #op f6 SET 6,(IY+n)
                #op fe SET 7,(IY+n)

                default:
                    return i16(0x4c00) | i16(op);
            }
        }
    }

    return -1;
}
