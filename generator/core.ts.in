#alloc frameBuffer[0x6600]: u8
#const FRAME_BUFFER_SIZE 0x6600

// allocate memory for 8 RAM, 4 ROM pages
// 0..7 - 128K RAM pages; 8 = 128 rom 0, 9 = 128 rom 1, 10 = 48 rom, 11 = scratch area for ROM writes
#alloc machineMemory[0x30000]: u8

#alloc memoryPageReadMap[4]: u8
#alloc memoryPageWriteMap[4]: u8

// NOTE: test/test.js hardcodes the memory offset of the registers.
// If you change anything above, update REGISTERS_ADDR in that file. kthx
#regpair AF A F
#regpair BC B C
#regpair DE D E
#regpair HL H L
#regpair AF_
#regpair BC_
#regpair DE_
#regpair HL_
#regpair IX IXH IXL
#regpair IY IYH IYL
#regpair SP
#regpair IR I R

#const FLAG_C 0x01
#const FLAG_N 0x02
#const FLAG_P 0x04
#const FLAG_V 0x04
#const FLAG_3 0x08
#const FLAG_H 0x10
#const FLAG_5 0x20
#const FLAG_Z 0x40
#const FLAG_S 0x80

#alloc halfcarryAddTable[8]: u8
halfcarryAddTable = [0, FLAG_H, FLAG_H, FLAG_H, 0, 0, 0, FLAG_H];

#alloc halfcarrySubTable[8]: u8
halfcarrySubTable = [0, 0, FLAG_H, 0, FLAG_H, 0, FLAG_H, FLAG_H];

#alloc overflowAddTable[8]: u8
overflowAddTable = [0, 0, 0, FLAG_V, FLAG_V, 0, 0, 0];
#alloc overflowSubTable[8]: u8
overflowSubTable = [0, FLAG_V, 0, 0, 0, 0, FLAG_V, 0];

#alloc sz53Table[0x100]: u8
#alloc parityTable[0x100]: u8
#alloc sz53pTable[0x100]: u8

#alloc screenEvents[36000]: u32

#alloc keyStates[8]: u8

let i:u8 = 0;
while (true) {
    sz53Table[i] = u8(i) & ( FLAG_3 | FLAG_5 | FLAG_S );
    let j = i;
    let parity:u8 = 0;
    for (let k:i8 = 0; k < 8; k++) {
        parity ^= j & 1;
        j >>= 1;
    }

    parityTable[i] = (parity ? 0 : FLAG_P);
    sz53pTable[i] = sz53Table[i] | parityTable[i];

    sz53Table[0] |= FLAG_Z;
    sz53pTable[0] |= FLAG_Z;
    i++;
    if (i == 0) break;
}


function buildScreenEventsTable(mainScreenStartTstate:u32, tstatesPerRow:u32):void {
    /* build screen events table: a list of which screen bytes should be fetched on which
    t-states. A sequence of: two u32s per event:
    - tstate number or 0xffffffff for end marker
    - screen address offset | (attr address offset << 16),
    or 0xffffffff if this is a 'fetch border' event
    */
    let screenEventPointer:u32 = 0;

    /* top border */
    for (let y:u32 = 0; y < 24; y++) {
        const rowTime:u32 = mainScreenStartTstate - (24 - y) * tstatesPerRow - 16;
        for (let x:u32 = 0; x < 160; x++) {
            screenEvents[screenEventPointer++] = rowTime + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    for (let y:u32 = 0; y < 192; y++) {
        const rowTime:u32 = mainScreenStartTstate + tstatesPerRow * y;
        const rowScreenOffset:u32 = ((y & 0xc0) << 5) | ((y & 0x07) << 8) | ((y & 0x38) << 2);
        const rowAttrOffset:u32 = 0x1800 | ((y & 0xf8) << 2);

        /* left border */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime - 16 + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }

        /* main screen */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime + 8 * x;
            const screenOffset:u32 = rowScreenOffset | (x << 1);
            const attrOffset:u32 = rowAttrOffset | (x << 1);
            screenEvents[screenEventPointer++] = screenOffset | (attrOffset << 16);
        }

        /* right border */
        for (let x:u32 = 0; x < 16; x++) {
            screenEvents[screenEventPointer++] = rowTime + 128 + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    /* bottom border */
    for (let y:u32 = 0; y < 24; y++) {
        const rowTime:u32 = mainScreenStartTstate + (192 + y) * tstatesPerRow - 16;
        for (let x:u32 = 0; x < 160; x++) {
            screenEvents[screenEventPointer++] = rowTime + (x & 0xfc);
            screenEvents[screenEventPointer++] = 0xffffffff;
        }
    }

    // add end marker
    screenEvents[screenEventPointer] = 0xffffffff;
}

let frameCycleCount:u32 = 69888;
let screenPageIndex:u32 = 5;
let pagingLocked:bool = 0;
let t:u32 = 0;
let pc:u16 = 0;
let iff1:bool = 0;
let iff2:bool = 0;
let im:u8 = 0;
let interruptible:bool = false;
let halted:bool = false;
let opcodePrefix:u8 = 0;
let framebufferIndex = 0;
let borderColour:u8 = 0;


let machineType:u32 = 48;
export function setMachineType(type:u32):void {
    machineType = type;
    if (type == 48 || type == 1212) {
        frameCycleCount = 69888;
        buildScreenEventsTable(14335, 224);
    } else {  // 128
        frameCycleCount = 70908;
        buildScreenEventsTable(14361, 228);
    }
    reset();
}
export function reset():void {
    if (machineType == 48) {
        memoryPageReadMap = [10, 5, 2, 0];
        memoryPageWriteMap = [11, 5, 2, 0];
        pagingLocked = 1;
    } else if (machineType == 1212) {
        // 1212 = test machine type with writeable ROM
        memoryPageReadMap = [10, 5, 2, 0];
        memoryPageWriteMap = [10, 5, 2, 0];
        pagingLocked = 1;
    } else {  // 128
        memoryPageReadMap = [8, 5, 2, 0];
        memoryPageWriteMap = [11, 5, 2, 0];
        pagingLocked = 0;
    }
    screenPageIndex = 5;
    t = 0;
    pc = 0;
    iff1 = iff2 = 0;
    im = 0;
    interruptible = false;
    halted = false;
    opcodePrefix = 0;
    framebufferIndex = 0;
}
setMachineType(48);

for (let i=0; i < 8; i++) {
    keyStates[i] = 0xff;
}

export function setRegisters(af:u16, bc:u16, de:u16, hl:u16, af_:u16, bc_:u16, de_:u16, hl_:u16, ix:u16, iy:u16, sp:u16, ir:u16):void {
    AF = af;
    BC = bc;
    DE = de;
    HL = hl;
    AF_ = af_;
    BC_ = bc_;
    DE_ = de_;
    HL_ = hl_;
    IX = ix;
    IY = iy;
    SP = sp;
    IR = ir;
}

export function setPC(val:u16):void {
    pc = val;
}
export function getPC():u16 {
    return pc;
}
export function setIFF1(val:bool):void {
    iff1 = val;
}
export function getIFF1():bool {
    return iff1;
}
export function setIFF2(val:bool):void {
    iff2 = val;
}
export function getIFF2():bool {
    return iff2;
}
export function setIM(val:u8):void {
    im = val;
}
export function getIM():u8 {
    return im;
}
export function setTStates(val:u32):void {
    t = val;
}
export function getTStates():u32 {
    return t;
}
export function setHalted(val:bool):void {
    halted = val;
}
export function getHalted():bool {
    return halted;
}


function readMem(addr:u16):u8 {
    t += 3;
    const pageOffset:u32 = u32(memoryPageReadMap[addr >> 14]) << 14;
    return machineMemory[pageOffset | (addr & 0x3fff)];
}

function writeMem(addr:u16, val:u8):void {
    t += 3;
    if (addr >= 0x4000 && addr < 0x5b00) {
        updateFramebuffer();
    }
    const pageOffset:u32 = u32(memoryPageWriteMap[addr >> 14]) << 14;
    machineMemory[pageOffset | (addr & 0x3fff)] = val;
}

export function peek(addr:u16):u8 {
    const pageOffset:u32 = u32(memoryPageReadMap[addr >> 14]) << 14;
    return machineMemory[pageOffset | (addr & 0x3fff)];
}
export function poke(addr:u16, val:u8):void {
    const pageOffset:u32 = u32(memoryPageWriteMap[addr >> 14]) << 14;
    machineMemory[pageOffset | (addr & 0x3fff)] = val;
}

export function readPort(addr:u16):u8 {
    if (machineType == 1212) {
        /*
        on port reads, the test machine just responds with the high byte of the port address.
        That's a thing now, I decided. (Well, Phil Kendall decided it to be exact.)
        */
        return u8(addr >> 8);
    }

    if (!(addr & 0x0001)) {
        /* poll keyboard */
        return pollKeyboard(u8(addr >> 8));
    } else if (!(addr & 0x00e0)) {
        /* kempston joystick */
        return 0;
    } else {
        return 0xff;
    }
}

export function writePort(addr:u16, val:u8):void {
    if (!(addr & 0x0001)) {
        /* border colour / speaker */
        borderColour = val & 0x07;
    } else if (!(addr & 0x8002)) {
        /* 128/+2 paging */
        if (pagingLocked) return;

        updateFramebuffer();  // so that screen switching happens at the right position

        memoryPageReadMap[3] = val & 0x07;
        memoryPageWriteMap[3] = val & 0x07;
        screenPageIndex = (val & 0x08) ? 7 : 5;
        memoryPageReadMap[0] = (val & 0x10) ? 9 : 8;
        pagingLocked = bool(val & 0x20);
    }
}

let screenEventPointer:u32 = 0;

function updateFramebuffer():void {
    /* process all of the screen bytes that are due up to the current tstate */
    const screenBaseAddr:u32 = screenPageIndex << 14;

    // end marker is 0xffffffff, which will always be greater than t
    while (screenEvents[screenEventPointer] <= t) {
        const addressWord:u32 = screenEvents[screenEventPointer + 1];
        if (addressWord == 0xffffffff) {
            frameBuffer[framebufferIndex++] = borderColour;
        } else {
            const screenAddr:u32 = screenBaseAddr | (addressWord & 0xffff);
            const attributeAddr:u32 = screenBaseAddr | (addressWord >> 16);
            frameBuffer[framebufferIndex++] = machineMemory[screenAddr];
            frameBuffer[framebufferIndex++] = machineMemory[attributeAddr];
            frameBuffer[framebufferIndex++] = machineMemory[screenAddr + 1];
            frameBuffer[framebufferIndex++] = machineMemory[attributeAddr + 1];
        }
        screenEventPointer += 2;
    }
}

export function keyDown(row:u8, mask:u8):void {
    keyStates[row] = keyStates[row] & ~mask;
}
export function keyUp(row:u8, mask:u8):void {
    keyStates[row] = keyStates[row] | mask;
}

function pollKeyboard(addr:u8):u8 {
    let result:u8 = 0xff;
    for (let row:u8 = 0; row < 8; row++) {
        if (!(addr & (1<<row))) {
            /* scan this row */
            result &= keyStates[row];
        }
    }
    return result;
}

export function runFrame():i16 {
    screenEventPointer = 0;
    framebufferIndex = 0;
    const result = runUntil(frameCycleCount);
    if (result != -1) {
        t = frameCycleCount;
        updateFramebuffer();
        return result;
    }

    updateFramebuffer();
    t -= frameCycleCount;

    return -1;
}

export function runUntil(maxT:u32):i16 {
    while (t < maxT || opcodePrefix) {
        //if (pc == 0x10af && machineMemory[0x5c3b] != 0x00) {
        //    return machineMemory[0x5c3b];
        //}

        if (t < 36 && iff1 && interruptible) {
            /* process interrupt */

            if (halted) {
                // move PC on from the HALT opcode
                pc++;
                halted = 0;
            }

            iff1 = iff2 = 0;

            /* push current PC in readiness for call to interrupt handler */
            let sp = SP;
            sp--;
            writeMem(sp, u8(pc >> 8));
            sp--;
            writeMem(sp, u8(pc & 0xff));
            SP = sp;

            if (im == 1) {
                pc = 0x0038;
                t += 7;
            } else if (im == 2) {
                const intVector:u16 = (u16(I) << 8) | 0xff;
                const lo = readMem(intVector);
                const hi = readMem(intVector + 1);
                pc = (lo | (hi << 8));
                t += 7;
            } else { /* im == 0 */
                pc = 0x0038;
                t += 6;
            }
        }

        interruptible = true; // unless overridden by opcode
        if (opcodePrefix == 0) {
            let op:u8 = readMem(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #optable base

                default:
                    return op;
            }
        } else if (opcodePrefix == 0xcb) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #optable cb

                default:
                    return i16(0xc00) | i16(op);
            }
        } else if (opcodePrefix == 0xdd) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #optable dd

                default:
                    return i16(0xd00) | i16(op);
            }
        } else if (opcodePrefix == 0xdc) {  // ddcb
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            const indexOffset:i8 = i8(readMem(pc++));
            let op:u8 = readMem(pc++);
            switch (op) {
                #optable ddcb

                default:
                    return i16(0x2c00) | i16(op);
            }
        } else if (opcodePrefix == 0xed) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #optable ed

                default:
                    return i16(0xe00) | i16(op);
            }
        } else if (opcodePrefix == 0xfd) {
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            let op:u8 = readMem(pc++);

            const r = R;
            R = (r & 0x80) | ((r + 1) & 0x7f);

            t++;  // 1T to decode in addition to the memory read
            switch (op) {
                #optable fd

                default:
                    return i16(0xf00) | i16(op);
            }
        } else if (opcodePrefix == 0xfc) {  // fdcb
            opcodePrefix = 0;  // for the next instruction (unless overridden)
            const indexOffset:i8 = i8(readMem(pc++));
            let op:u8 = readMem(pc++);
            switch (op) {
                #optable fdcb

                default:
                    return i16(0x4c00) | i16(op);
            }
        }
    }

    return -1;
}
