#alloc frameBuffer[0x3000]: u8
#const FRAME_BUFFER_SIZE 0x3000
#alloc machineMemory[0x10000]: u8

export const FRAME_CYCLE_COUNT:u32 = 69888;

#regpair AF A F
#regpair BC B C
#regpair DE D E
#regpair HL H L
#regpair AF_
#regpair BC_
#regpair DE_
#regpair HL_
#regpair IX IXH IXL
#regpair IY IYH IYL
#regpair SP
#regpair IR I R

#const FLAG_C 0x01
#const FLAG_N 0x02
#const FLAG_P 0x04
#const FLAG_V 0x04
#const FLAG_3 0x08
#const FLAG_H 0x10
#const FLAG_5 0x20
#const FLAG_Z 0x40
#const FLAG_S 0x80

#alloc halfcarryAddTable[8]: u8
halfcarryAddTable = [0, FLAG_H, FLAG_H, FLAG_H, 0, 0, 0, FLAG_H];

#alloc halfcarrySubTable[8]: u8
halfcarrySubTable = [0, 0, FLAG_H, 0, FLAG_H, 0, FLAG_H, FLAG_H];

#alloc overflowAddTable[8]: u8
overflowAddTable = [0, 0, 0, FLAG_V, FLAG_V, 0, 0, 0];
#alloc overflowSubTable[8]: u8
overflowSubTable = [0, FLAG_V, 0, 0, 0, 0, FLAG_V, 0];

#alloc sz53Table[0x100]: u8
#alloc parityTable[0x100]: u8
#alloc sz53pTable[0x100]: u8

let i:u8 = 0;
while (true) {
    sz53Table[i] = u8(i) & ( FLAG_3 | FLAG_5 | FLAG_S );
    let j = i;
    let parity:u8 = 0;
    for (let k:i8 = 0; k < 8; k++) {
        parity ^= j & 1;
        j >>= 1;
    }

    parityTable[i] = (parity ? 0 : FLAG_P);
    sz53pTable[i] = sz53Table[i] | parityTable[i];

    sz53Table[0] |= FLAG_Z;
    sz53pTable[0] |= FLAG_Z;
    i++;
    if (i == 0) break;
}


let frameNum:u8 = 1;
let t:u32 = 0;
let pc:u16 = 0;
let iff1:bool = 0;
let iff2:bool = 0;
let opcodePrefix:u8 = 0;

function readMem(addr:u16):u8 {
    t += 3;
    return machineMemory[addr];
}

function writeMem(addr:u16, val:u8):void {
    t += 3;
    if (addr & 0xc000) {
        machineMemory[addr] = val;
    }
}

export function runFrame():i16 {
    while (t < FRAME_CYCLE_COUNT) {
        let op:u8 = readMem(pc++);
        t++;  // 1T to decode in addition to the memory read
        if (opcodePrefix == 0) {
            switch (op) {
                #op 00 NOP
                #op 06 LD B,n
                #op 0b DEC BC
                #op 0e LD C,n
                #op 11 LD DE,nn
                #op 16 LD D,n
                #op 1b DEC DE
                #op 1e LD E,n
                #op 26 LD H,n
                #op 2e LD L,n
                #op 2b DEC HL
                #op 36 LD (HL),n
                #op 3b DEC SP
                #op 3e LD A,n

                #op 40 LD B,B
                #op 41 LD B,C
                #op 42 LD B,D
                #op 43 LD B,E
                #op 44 LD B,H
                #op 45 LD B,L
                #op 47 LD B,A
                #op 48 LD C,B
                #op 49 LD C,C
                #op 4a LD C,D
                #op 4b LD C,E
                #op 4c LD C,H
                #op 4d LD C,L
                #op 4f LD C,A

                #op 50 LD D,B
                #op 51 LD D,C
                #op 52 LD D,D
                #op 53 LD D,E
                #op 54 LD D,H
                #op 55 LD D,L
                #op 57 LD D,A
                #op 58 LD E,B
                #op 59 LD E,C
                #op 5a LD E,D
                #op 5b LD E,E
                #op 5c LD E,H
                #op 5d LD E,L
                #op 5f LD E,A

                #op 60 LD H,B
                #op 61 LD H,C
                #op 62 LD H,D
                #op 63 LD H,E
                #op 64 LD H,H
                #op 65 LD H,L
                #op 67 LD H,A
                #op 68 LD L,B
                #op 69 LD L,C
                #op 6a LD L,D
                #op 6b LD L,E
                #op 6c LD L,H
                #op 6d LD L,L
                #op 6f LD L,A

                #op a8 XOR B
                #op a9 XOR C
                #op aa XOR D
                #op ab XOR E
                #op ac XOR H
                #op ad XOR L
                #op af XOR A
                #op c3 JP nn
                #op c5 PUSH BC
                #op cb prefix cb
                #op d3 OUT (n),A
                #op d5 PUSH DE
                #op e5 PUSH HL
                #op ed prefix ed
                #op f3 DI
                #op f5 PUSH AF

                default:
                    return op;
            }
        } else if (opcodePrefix == 0xed) {
            switch (op) {
                #op 47 LD I,A

                default:
                    return i16(0xe00) | i16(op);
            }
            opcodePrefix = 0;
        }
    }
    t -= FRAME_CYCLE_COUNT;

    for (let i:u16 = 0; i < FRAME_BUFFER_SIZE; i++) {
        store<u8>(i, i + frameNum);
    }
    frameNum += 2;

    return -1;
}
